<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Flooding Simulator</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#f7f7f7" />
    <meta name="description" content="树梢测试" />
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            position: fixed;
            display: flex;
            background-color: #f7f7f7;
            height: 100%;
            width: 100%;
            font-size: 14px;
        }

        button {
            cursor: pointer;
            box-sizing: border-box;
            transition: all 0.1s ease-in-out;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            text-decoration: none;
            min-width: 32px;
            padding: 0 8px;
            height: 32px;
            min-height: 32px;
            width: max-content;
            border: 2px solid transparent;
            border-radius: 2px;
            color: #262626;
            fill: #262626;
            background: #E5E5E5;
        }

        button.primary {
            color: #FFFFFF;
            fill: #FFFFFF;
            background: #0078D4;
        }

        #network-info,
        #node-info {
            flex-basis: 250px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            box-shadow: 0px 0px 12px 0px rgba(0, 0, 0, 0.2);
            padding: 24px;
            z-index: 1;
            overflow: auto;
        }

        #network-info-list,
        #node-info-list {
            list-style: none;
            display: flex;
            flex-direction: column;
        }

        #network-info>*,
        #node-info>* {
            margin-bottom: 24px;
        }

        #network-info-list>li,
        #node-info-list>li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }

        #network-info-list input {
            margin: 0;
            box-sizing: border-box;
            transition: all 0.2s ease-in-out;
            font-family: inherit;
            font-size: 14px;
            line-height: 20px;
            font-weight: 400;
            background: #F7F7F7;
            border: 1px solid #B6B6B6;
            color: #262626;
            padding: 0 11px;
            border-radius: 2px;
            height: 32px;
            width: 72px;
        }

        main {
            flex-grow: 1;
            display: flex;
            align-items: center;
            overflow: auto;
            flex-shrink: 1;
        }

        #canvas-wrapper {
            padding: 12px 24px;
            width: max-content;
            margin: auto;
        }

        #canvas {
            background-color: white;
            box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            z-index: 0;
        }
    </style>
</head>

<body>
    <aside id="network-info">
        <h2>传感器网络信息</h2>
        <ul id="network-info-list">
            <li>
                <div>节点数目</div>
                <div id="node-count"></div>
            </li>
            <li>
                <div>消息数目</div>
                <div id="msg-count"></div>
            </li>
            <li>
                <div>初始 TTL</div>
                <input type="number" id="ttl-setter"></input>
            </li>
            <li>
                <div>最大通信距离</div>
                <input type="number" id="max-find-dst-setter"></input>
            </li>
        </ul>
        <button id="pause-button" class="primary">暂停</button>
        <button id="add-node-button">添加节点</button>
        <button id="show-dst-button">是否显示距离</button>
        <h2>使用说明</h2>
        <p><strong>拖动</strong>节点，节点将自动搜索可达节点，并用线显示信道。</p>
        <p>点击节点，将<strong>聚焦节点</strong>，聚焦节点的信息将显示在右侧面板，并可通过该面板进行节点相关操作，如<strong>发送消息</strong></p>
        <p>左侧面板可查看和设置网络参数，如<strong>最大可达距离</strong>，<strong>初始 TTL</strong>等。</p>
    </aside>
    <main>
        <div id="canvas-wrapper"></div>
    </main>
    <aside id="node-info">
        <h2>焦点节点信息</h2>
        <ul id="node-info-list">
            <li>
                <div>节点 ID</div>
                <div id="node-ID"></div>
            </li>
            <li>
                <div>连接数</div>
                <div id="connections-count"></div>
            </li>
            <li>
                <div>坐标 x</div>
                <div id="node-x"></div>
            </li>
            <li>
                <div>坐标 y</div>
                <div id="node-y"></div>
            </li>
        </ul>
        <button id="send-message-button" class="primary">发送消息</button>
        <button id="remove-node-button">删除节点</button>
    </aside>
    <script>
        const CANVAS_W = 1000
        const CANVAS_H = 1000
        const C_VIEW_W = 500
        const C_VIEW_H = 500
        const MSG_SPEED = 80 / 1000

        const NODE_RADIUS = 16
        const FOCUS_RADIUS = 24
        const MSG_RADIUS = 6
        const DEFAULT_MAX_TTL = 3
        const DEFAULT_MAX_FIND_DST = 300

        const canvasWrapperEle = document.getElementById('canvas-wrapper')
        const nodeCountEle = document.getElementById('node-count')
        const addNodeButton = document.getElementById('add-node-button')
        const removeNodeButton = document.getElementById('remove-node-button')
        const ttlSetterEle = document.getElementById('ttl-setter')
        const maxFindDstSetter = document.getElementById('max-find-dst-setter')
        const connectionsCountEle = document.getElementById('connections-count')
        const nodeIDEle = document.getElementById('node-ID')
        const nodeXEle = document.getElementById('node-x')
        const nodeYEle = document.getElementById('node-y')
        const showDstButton = document.getElementById('show-dst-button')
        const sendMessageButton = document.getElementById('send-message-button')
        const msgCountEle = document.getElementById('msg-count')

        const bufferCanvas = document.createElement('canvas')
        const bufferCtx = bufferCanvas.getContext('2d')

        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')

        ttlSetterEle.value = DEFAULT_MAX_TTL
        maxFindDstSetter.value = DEFAULT_MAX_FIND_DST
        addNodeButton.addEventListener('click', () => { State.emit('add-node') })
        showDstButton.addEventListener('click', (e) => { State.emit('show-dst', e) })
        canvas.addEventListener('mouseup', (e) => { State.emit('canvas-mouseup', e) })
        removeNodeButton.addEventListener('click', () => { State.emit('remove-node') })
        ttlSetterEle.addEventListener('change', (e) => { State.emit('ttl-change', e) })
        canvas.addEventListener('mousedown', (e) => { State.emit('canvas-mousedown', e) })
        canvas.addEventListener('mousemove', (e) => { State.emit('canvas-mousemove', e) })
        maxFindDstSetter.addEventListener('change', (e) => { State.emit('max-find-dst-change', e) })
        sendMessageButton.addEventListener('click', (e) => { State.emit('send-message-button-click') })


        const defaultNode = {
            ID: 0,
            x: 0,
            y: 0
        }

        const defaultMessage = {
            ID: 0,
            sendTime: 0,
            TTL: 0,
            src: 0,
            dst: 0,
        }

        const defaultEdge = {
            node1: 0,
            node2: 0,
            dst: 0
        }

        const defaultState = {
            nodes: [, defaultNode].slice(0, 0),
            edges: [, defaultEdge].slice(0, 0),
            messages: [, defaultMessage].slice(0, 0),
            maxTTL: DEFAULT_MAX_TTL,
            pickedUpBrush: false,
            nodeIsPickedUp: -1,
            focusedNodeIndex: 0,
            stroking: false,
            maxFindDst: DEFAULT_MAX_FIND_DST,
            messagesCount: 0,
            nodesCount: 11,
            showDist: false
        }

        let state = defaultState

        function createListener(name = '') {
            const defaultEAF = { e: '', f: () => { } }

            let eAfs = [defaultEAF].slice(0, 0)

            const on = (e = '', f = () => { }) => {
                eAfs.push({ e, f })
            }

            const emit = (e = '', ...args) => {
                for (let i in eAfs) {
                    if (eAfs[i].e === e) {
                        eAfs[i].f(...args)
                        return true
                    }
                }
                console.warn(`[ ${name} 未捕获事件 "${e}" ]`)
                return false
            }
            return { emit, on }
        }

        const Dom = getDom()
        const State = getData()

        function getData() {
            const { emit, on } = createListener('State')

            let nodes = [, defaultNode].slice(0, 0)
            let edges = [, defaultEdge].slice(0, 0)
            let messages = [, defaultMessage].slice(0, 0)
            let maxTTL = DEFAULT_MAX_TTL
            let pickedUpBrush = false
            let nodeIsPickedUp = -1
            let focusedNodeIndex = 0
            let stroking = false
            let maxFindDst = DEFAULT_MAX_FIND_DST
            let messagesCount = 0
            let nodesCount = 11
            let showDist = false

            return {
                emit,
                on,
                getNodes: () => nodes,
                getEdges: () => edges,
                getMsgs: () => messages,
                getMaxTTL: () => maxTTL,
                getPickedUpBrush: () => pickedUpBrush,
                getNodeIsPickedUp: () => nodeIsPickedUp,
                getFocusedNodeIndex: () => focusedNodeIndex,
                getStroking: () => stroking,
                getMaxFindDst: () => maxFindDst,
                getMessagesCount: () => messagesCount,
                getNodesCount: () => nodesCount,
                getShowDist: () => showDist
            }
        }

        function getDom() {
            const { emit, on } = createListener('Dom')
            return { emit, on }
        }

        bufferCanvas.style = `height: ${C_VIEW_H}px; width: ${C_VIEW_W}px;`
        bufferCanvas.width = 1000
        bufferCanvas.height = 1000
        canvas.id = 'canvas'
        canvas.style = `height: ${C_VIEW_H}px; width: ${C_VIEW_W}px;`
        canvas.width = 1000
        canvas.height = 1000
        canvasWrapperEle.appendChild(canvas)

        addListeners()

        State.emit('init-nodes')

        mainLoop(performance.now())


        // ===== Functions =====

        function mainLoop(now = performance.now()) {
            requestAnimationFrame((now) => { mainLoop(now) })

            State.emit('update-messages', now)
            Dom.emit('update-dom')
            Dom.emit('update-canvas', now)
        }


        function countConnections(nodeIndex) {
            return state.edges.filter(edge => (
                edge.node1 === nodeIndex || edge.node2 === nodeIndex
            )).length
        }
        function mouseOnNode(x, y) {
            for (let i = state.nodes.length - 1; i > -1; i--) {
                const xNode = state.nodes[i].x
                const yNode = state.nodes[i].y
                const dst = ((xNode - x) ** 2 + (yNode - y) ** 2) ** 0.5
                if (dst <= NODE_RADIUS) return i
            }
            return -1
        }

        function addListeners() {
            Dom.on('aaa', (s) => console.log(s))
            Dom.on('update-node-info-panel', () => {
                const nodeIndex = state.focusedNodeIndex
                const connectionsCount = countConnections(nodeIndex)
                if (connectionsCountEle.textContent !== connectionsCount.toString())
                    connectionsCountEle.textContent = connectionsCount.toString()
                if (nodeIDEle.textContent !== state.nodes[nodeIndex]?.ID.toString())
                    nodeIDEle.textContent = state.nodes[nodeIndex]?.ID
                if (nodeXEle.textContent !== state.nodes[nodeIndex]?.x.toString())
                    nodeXEle.textContent = state.nodes[nodeIndex]?.x
                if (nodeYEle.textContent !== state.nodes[nodeIndex]?.y)
                    nodeYEle.textContent = state.nodes[nodeIndex]?.y
            })
            Dom.on('update-dom', () => {
                if (parseInt(nodeCountEle.textContent) !== state.nodes.length) {
                    nodeCountEle.textContent = state.nodes.length.toString()
                }
                if (!isNaN(msgCountEle.textContent)
                    && parseInt(msgCountEle.textContent) !== state.messages.length) {
                    msgCountEle.textContent = state.messages.length.toString()
                }
                Dom.emit('update-node-info-panel')
            })
            Dom.on('paint-edges', (nodes = [defaultNode], edges = [defaultEdge]) => {
                bufferCtx.strokeStyle = 'rgb(0, 120, 212)'
                bufferCtx.lineWidth = 2
                edges.forEach(edge => {
                    const x1 = nodes[edge.node1].x
                    const y1 = nodes[edge.node1].y
                    const x2 = nodes[edge.node2].x
                    const y2 = nodes[edge.node2].y
                    bufferCtx.beginPath()
                    bufferCtx.moveTo(x1, y1)
                    bufferCtx.lineTo(x2, y2)
                    bufferCtx.stroke()
                })
            })
            Dom.on('paint-nodes', (nodes = [defaultNode], focusedNodeIndex = 0) => {
                const focusedNode = nodes[focusedNodeIndex]
                bufferCtx.lineWidth = 4
                // 绘制圆点
                bufferCtx.strokeStyle = '#0078d4'
                bufferCtx.fillStyle = '#c7e0f4'
                nodes.forEach(node => {
                    bufferCtx.beginPath()
                    bufferCtx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI)
                    bufferCtx.stroke()
                    bufferCtx.fill()
                })
                // 绘制聚焦圆环
                bufferCtx.strokeStyle = '#0078d4af'
                bufferCtx.beginPath()
                bufferCtx.arc(focusedNode.x, focusedNode.y, FOCUS_RADIUS, 0, 2 * Math.PI)
                bufferCtx.stroke()
                // 绘制标签
                bufferCtx.fillStyle = '#0078d4'
                bufferCtx.font = '20px consolas'
                bufferCtx.textAlign = 'center'
                bufferCtx.textBaseline = 'middle'
                nodes.forEach(node => {
                    const IDText = node.ID.toString()
                    bufferCtx.fillText(IDText, node.x, node.y)
                })
            })
            Dom.on('paint-messages', (nodes = [defaultNode], edges = [defaultEdge], msgs = [defaultMessage], now = 0) => {
                bufferCtx.lineWidth = 2
                bufferCtx.font = '20px consolas'
                bufferCtx.textAlign = 'center'
                bufferCtx.textBaseline = 'middle'
                bufferCtx.fillStyle = '#dff6dd'
                bufferCtx.strokeStyle = '#107c10'
                // 绘制圆点
                for (let i = 0; i < msgs.length; i++) {
                    const msg = msgs[i]
                    const srcNode = nodes[msg.src]
                    const dstNode = nodes[msg.dst]
                    const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                    const neededTime = dist / MSG_SPEED
                    const coveredTime = now - msg.sendTime
                    const percentage = coveredTime / neededTime
                    const coveredX = (dstNode.x - srcNode.x) * percentage
                    const coveredY = (dstNode.y - srcNode.y) * percentage
                    const x = srcNode.x + coveredX
                    const y = srcNode.y + coveredY
                    bufferCtx.beginPath()
                    bufferCtx.arc(x, y, MSG_RADIUS, 0, 2 * Math.PI)
                    bufferCtx.fill()
                    bufferCtx.beginPath()
                    bufferCtx.arc(x, y, MSG_RADIUS, 0, 2 * Math.PI)
                    bufferCtx.stroke()
                }
                // 绘制标签
                bufferCtx.fillStyle = '#222222'
                for (let i = 0; i < msgs.length; i++) {
                    const msg = msgs[i]
                    const srcNode = nodes[msg.src]
                    const dstNode = nodes[msg.dst]
                    const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                    const neededTime = dist / MSG_SPEED
                    const coveredTime = now - msg.sendTime
                    const percentage = coveredTime / neededTime
                    const coveredX = (dstNode.x - srcNode.x) * percentage
                    const coveredY = (dstNode.y - srcNode.y) * percentage
                    const x = srcNode.x + coveredX
                    const y = srcNode.y + coveredY
                    const IDText = msg.ID.toString()
                    bufferCtx.fillText(IDText, x, y + MSG_RADIUS + 10)
                }
            })
            Dom.on('paint-edge-tags', (nodes = [defaultNode], edges = [defaultEdge]) => {
                bufferCtx.fillStyle = '#222222'
                bufferCtx.font = '20px consolas'
                bufferCtx.textAlign = 'center'
                bufferCtx.textBaseline = 'middle'
                edges.forEach(edge => {
                    const dstText = edge.dst.toFixed(2)
                    const textWidth = bufferCtx.measureText(dstText).width
                    const x1 = nodes[edge.node1].x
                    const y1 = nodes[edge.node1].y
                    const x2 = nodes[edge.node2].x
                    const y2 = nodes[edge.node2].y
                    const xText = (x1 + x2) / 2
                    const yText = (y1 + y2) / 2
                    bufferCtx.fillText(dstText, xText, yText)
                })
            })
            Dom.on('update-canvas', (now = 0) => {
                const nodes = state.nodes
                const edges = state.edges
                const msgs = state.messages
                const showDist = state.showDist
                const focusedNodeIndex = state.focusedNodeIndex

                bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height)

                Dom.emit('paint-edges', nodes, edges)
                Dom.emit('paint-nodes', nodes, focusedNodeIndex)
                Dom.emit('paint-messages', nodes, edges, msgs, now)
                if (showDist) Dom.emit('paint-edge-tags', nodes, edges)

                ctx.clearRect(0, 0, canvas.width, canvas.height)
                ctx.drawImage(bufferCanvas, 0, 0)
            })

            State.on('add-node', () => {
                state.nodesCount++
                state.nodes.push({
                    ID: state.nodesCount,
                    x: NODE_RADIUS * 2,
                    y: NODE_RADIUS * 2
                })
                State.emit('update-edges')
            })
            State.on('ttl-change', (e = new Event) => {
                state.maxTTL = e.currentTarget.value
            })
            State.on('max-find-dst-change', (e = new Event) => {
                state.maxFindDst = e.currentTarget.value
                State.emit('update-edges')
            })
            State.on('canvas-mousedown', (e = new MouseEvent) => {
                const x = e.offsetX / C_VIEW_W * CANVAS_W
                const y = e.offsetY / C_VIEW_H * CANVAS_H
                const nodeIndex = mouseOnNode(x, y)
                if (nodeIndex !== -1) State.emit('pick-up-node', nodeIndex)
            })
            State.on('canvas-mousemove', (e = new MouseEvent) => {
                const x = e.offsetX / C_VIEW_W * CANVAS_W
                const y = e.offsetY / C_VIEW_H * CANVAS_H
                if (state.nodeIsPickedUp !== -1) State.emit('dragging-node', x, y)
            })
            State.on('canvas-mousemove', (e = new MouseEvent) => {
                const x = e.offsetX / C_VIEW_W * CANVAS_W
                const y = e.offsetY / C_VIEW_H * CANVAS_H
                if (state.nodeIsPickedUp !== -1) State.emit('dragging-node', x, y)
            })
            State.on('canvas-mouseup', (e = new MouseEvent) => {
                const x = e.offsetX / C_VIEW_W * CANVAS_W
                const y = e.offsetY / C_VIEW_H * CANVAS_H
                if (state.nodeIsPickedUp !== -1) State.emit('put-down-node')
            })
            State.on('remove-node', () => {
                const node = state.focusedNodeIndex
                state.nodes = state.nodes.filter((item, idx) => idx !== node)
                State.emit('focus-node', 0)
                State.emit('update-edges')
            })
            State.on('show-dst', () => {
                state.showDist = !state.showDist
            })
            State.on('send-message-button-click', () => {
                const nodeIndex = state.focusedNodeIndex
                const edges = state.edges
                for (let i in edges) {
                    if (edges[i].node1 === nodeIndex) {
                        State.emit('send-message', nodeIndex, edges[i].node2)
                    }
                    else if (edges[i].node2 === nodeIndex) {
                        State.emit('send-message', nodeIndex, edges[i].node1)
                    }
                }
            })
            State.on('set-nodes', (nodes = [defaultNode]) => {
                state.nodes = nodes
                State.emit('update-edges')
                State.emit('focus-node', 0)
            })
            State.on('pick-up-node', (node = defaultNode) => {
                state.nodeIsPickedUp = node
                State.emit('focus-node', node)
            })
            State.on('dragging-node', (x = 0, y = 0) => {
                const node = state.nodeIsPickedUp
                state.nodes[node].x = x
                state.nodes[node].y = y
                State.emit('focus-node', node)
                State.emit('update-edges')
            })
            State.on('put-down-node', () => {
                const node = state.nodeIsPickedUp
                state.nodeIsPickedUp = -1
                State.emit('focus-node', node)
                State.emit('update-edges')
            })
            State.on('focus-node', (node = defaultNode) => {
                state.focusedNodeIndex = node
                Dom.emit('update-node-info-panel', node)
            })
            State.on('update-edges', () => {
                const nodes = state.nodes
                let edges = []
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const x_1 = nodes[i].x
                        const y_1 = nodes[i].y
                        const x_2 = nodes[j].x
                        const y_2 = nodes[j].y
                        const dst = ((x_1 - x_2) ** 2 + (y_1 - y_2) ** 2) ** 0.5
                        if (dst <= state.maxFindDst) {
                            edges.push({
                                node1: i,
                                node2: j,
                                dst,
                            })
                        }
                    }
                }
                state.edges = edges
            })
            State.on('send-message', (src = 0, dst = 0, sendTime = performance.now(), TTL = state.maxTTL) => {
                state.messagesCount++
                state.messages.push({
                    ID: state.messagesCount,
                    sendTime,
                    TTL,
                    src,
                    dst
                })
            })
            State.on('update-messages', (now = performance.now()) => {
                for (let i = 0; i < state.messages.length; i++) {
                    const msg = state.messages[i]
                    const srcNode = state.nodes[msg.src]
                    const dstNode = state.nodes[msg.dst]
                    const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                    const neededTime = dist / MSG_SPEED
                    if (now - msg.sendTime < neededTime) {
                        continue
                    }
                    if (msg.TTL - 1 === 0) {
                        deleteMsg(msg.ID)
                        i--
                        continue
                    }
                    for (let i in state.edges) {
                        const edge = state.edges[i]
                        if (edge.node1 === msg.dst && edge.node2 !== msg.src) {
                            State.emit('send-message', msg.dst, edge.node2, neededTime + msg.sendTime, msg.TTL - 1)
                        }
                        else if (edge.node2 === msg.dst && edge.node1 !== msg.src) {
                            State.emit('send-message', msg.dst, edge.node1, neededTime + msg.sendTime, msg.TTL - 1)
                        }
                    }
                    deleteMsg(msg.ID)
                    i--

                    function deleteMsg(ID) {
                        state.messages = state.messages.filter((msg) => msg.ID !== ID)
                    }
                }
            })
            State.on('init-nodes', () => {
                let nodes = []
                for (let i = 1; i < 12; i++) {
                    nodes.push({
                        ID: i + 1,
                        x: Math.round((Math.random() - 0.5) * 600 + CANVAS_W / 2),
                        y: Math.round((Math.random() - 0.5) * 600 + CANVAS_H / 2)
                    })
                }
                State.emit('set-nodes', nodes)
            })
        }
    </script>
</body>

</html>