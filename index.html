<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Flooding Simulator</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#f7f7f7" />
    <meta name="description" content="树梢测试" />
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            position: fixed;
            display: flex;
            background-color: #f7f7f7;
            height: 100%;
            width: 100%;
            font-size: 14px;
        }

        button {
            cursor: pointer;
            box-sizing: border-box;
            transition: all 0.1s ease-in-out;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            text-decoration: none;
            min-width: 32px;
            padding: 0 8px;
            height: 32px;
            min-height: 32px;
            width: max-content;
            border: 2px solid transparent;
            border-radius: 2px;
            color: #262626;
            fill: #262626;
            background: #E5E5E5;
        }

        button.primary {
            color: #FFFFFF;
            fill: #FFFFFF;
            background: #0078D4;
        }

        #network-info,
        #node-info {
            flex-basis: 250px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            box-shadow: 0px 0px 12px 0px rgba(0, 0, 0, 0.2);
            padding: 24px;
            z-index: 1;
            overflow: auto;
        }

        #network-info-list,
        #node-info-list {
            list-style: none;
            display: flex;
            flex-direction: column;
        }

        #network-info>*,
        #node-info>* {
            margin-bottom: 24px;
        }

        #network-info-list>li,
        #node-info-list>li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }

        #network-info-list input {
            margin: 0;
            box-sizing: border-box;
            transition: all 0.2s ease-in-out;
            font-family: inherit;
            font-size: 14px;
            line-height: 20px;
            font-weight: 400;
            background: #F7F7F7;
            border: 1px solid #B6B6B6;
            color: #262626;
            padding: 0 11px;
            border-radius: 2px;
            height: 32px;
            width: 72px;
        }

        main {
            flex-grow: 1;
            display: flex;
            align-items: center;
            overflow: auto;
            flex-shrink: 1;
        }

        #canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 24px;
            width: fit-content;
            min-width: fit-content;
            margin: auto;
        }

        #nodes-edges-canvas {
            background-color: white;
            box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            z-index: 0;
        }

        #messages-canvas {
            position: static;
            border-radius: 8px;
            z-index: 0;
        }
    </style>
</head>

<body>
    <aside id="network-info">
        <h2>传感器网络信息</h2>
        <ul id="network-info-list">
            <li>
                <div>节点数目</div>
                <div id="node-count"></div>
            </li>
            <li>
                <div>消息数目</div>
                <div id="msg-count"></div>
            </li>
            <li>
                <div>初始 TTL</div>
                <input type="number" id="ttl-setter"></input>
            </li>
            <li>
                <div>最大通信距离</div>
                <input type="number" id="max-find-dst-setter"></input>
            </li>
        </ul>
        <button id="pause-button" class="primary">暂停</button>
        <button id="add-node-button">添加节点</button>
        <button id="show-dst-button">是否显示距离</button>
        <h2>使用说明</h2>
        <p><strong>拖动</strong>节点，节点将自动搜索可达节点，并用线显示信道。</p>
        <p>点击节点，将<strong>聚焦节点</strong>，聚焦节点的信息将显示在右侧面板，并可通过该面板进行节点相关操作，如<strong>发送消息</strong></p>
        <p>左侧面板可查看和设置网络参数，如<strong>最大可达距离</strong>，<strong>初始 TTL</strong>等。</p>
    </aside>
    <main>
        <div id="canvas-wrapper">
            <canvas id="nodes-edges-canvas"></canvas>
            <canvas id="messages-canvas"></canvas>
        </div>
    </main>
    <aside id="node-info">
        <h2>焦点节点信息</h2>
        <ul id="node-info-list">
            <li>
                <div>节点 ID</div>
                <div id="node-ID"></div>
            </li>
            <li>
                <div>连接数</div>
                <div id="connections-count"></div>
            </li>
            <li>
                <div>坐标 x</div>
                <div id="node-x"></div>
            </li>
            <li>
                <div>坐标 y</div>
                <div id="node-y"></div>
            </li>
        </ul>
        <button id="send-message-button" class="primary">发送消息</button>
        <button id="remove-node-button">删除节点</button>
    </aside>
    <script>
        const CANVAS_W = 1000
        const CANVAS_H = 1000
        const C_VIEW_W = 500
        const C_VIEW_H = 500
        const MSG_SPEED = 80 / 1000

        const NODE_RADIUS = 16
        const FOCUS_RADIUS = 24
        const MSG_RADIUS = 6
        const DEFAULT_MAX_TTL = 3
        const DEFAULT_MAX_FIND_DST = 300

        const ONE_MSG_CIRCLE_CANVAS = getOneMsgCircleCanvas()
        const ONE_NODE_CIRCLE_CANVAS = getOneNodeCircleCanvas()
        const ONE_NODE_F_CIRCLE_CANVAS = getOneNodeFCircleCanvas()

        const defaultNode = {
            ID: 0,
            x: 0,
            y: 0
        }

        const defaultMessage = {
            ID: 0,
            sendTime: 0,
            TTL: 0,
            src: 0,
            dst: 0,
        }

        const defaultEdge = {
            node1: 0,
            node2: 0,
            dst: 0
        }

        createESV.viewElements = (() => {
            const nodeCountEle = document.getElementById('node-count')
            const connectionsCountEle = document.getElementById('connections-count')
            const nodeIDEle = document.getElementById('node-ID')
            const nodeXEle = document.getElementById('node-x')
            const nodeYEle = document.getElementById('node-y')
            const msgCountEle = document.getElementById('msg-count')

            document.getElementById('remove-node-button').addEventListener('click', () => { emit('remove-node') })
            document.getElementById('add-node-button').addEventListener('click', () => { emit('add-node') })
            document.getElementById('ttl-setter').addEventListener('change', (e) => { emit('ttl-change', e) })
            document.getElementById('max-find-dst-setter').addEventListener('change', (e) => { emit('max-find-dst-change', e) })
            document.getElementById('send-message-button').addEventListener('click', (e) => { emit('send-message-button-click') })
            document.getElementById('show-dst-button').addEventListener('click', (e) => { emit('show-dst', e) })
            document.getElementById('ttl-setter').value = DEFAULT_MAX_TTL
            document.getElementById('max-find-dst-setter').value = DEFAULT_MAX_FIND_DST


            let nodesEdgesCanvas = document.getElementById('nodes-edges-canvas')
            let nodesEdgesCtx = nodesEdgesCanvas.getContext('2d')
            nodesEdgesCanvas.style = `height: ${C_VIEW_H}px; width: ${C_VIEW_W}px;`
            nodesEdgesCanvas.width = CANVAS_W
            nodesEdgesCanvas.height = CANVAS_H

            let messagesCanvas = document.getElementById('messages-canvas')
            let messagesCtx = messagesCanvas.getContext('2d')
            messagesCanvas.style = `height: ${C_VIEW_H}px; width: ${C_VIEW_W}px; margin-top: ${-C_VIEW_H}px`
            messagesCanvas.width = CANVAS_W
            messagesCanvas.height = CANVAS_H
            messagesCanvas.addEventListener('mouseup', (e) => { emit('canvas-mouseup', e) })
            messagesCanvas.addEventListener('mousedown', (e) => { emit('canvas-mousedown', e) })
            messagesCanvas.addEventListener('mousemove', (e) => { emit('canvas-mousemove', e) })

            return {
                nodeCountEle,
                connectionsCountEle,
                nodeIDEle,
                nodeXEle,
                nodeYEle,
                msgCountEle,
                messagesCanvas,
                messagesCtx,
                nodesEdgesCanvas,
                nodesEdgesCtx,
            }
        })()

        createESV.defaultState = {
            now: 0,
            nodes: [, defaultNode].slice(0, 0),
            messages: [, defaultMessage].slice(0, 0),
            maxTTL: DEFAULT_MAX_TTL,
            nodeIsPickedUp: -1,
            focusedNodeIndex: 0,
            maxFindDst: DEFAULT_MAX_FIND_DST,
            messagesCount: 0,
            nodesCount: 11,
            showDist: false
        }

        const { emit, on, setEffect } = createESV()

        setEffect('nodes', (states, vEles) => {
            const nodes = states.nodes
            const nodeIndex = states.focusedNodeIndex
            const edges = getEdges(nodes, states.maxFindDst)
            const connectionsCount = countConnections(nodeIndex, edges)
            const showDist = states.showDist
            const focusedNodeIndex = states.focusedNodeIndex
            vEles.nodeCountEle.textContent = nodes.length
            vEles.connectionsCountEle.textContent = connectionsCount
            vEles.nodeIDEle.textContent = nodes[nodeIndex]?.ID
            vEles.nodeXEle.textContent = nodes[nodeIndex]?.x
            vEles.nodeYEle.textContent = nodes[nodeIndex]?.y
            nodesEdgesRePaint(states, vEles)
        })
        setEffect('maxFindDst', (state, vEles) => {
            nodesEdgesRePaint(state, vEles)
        })
        setEffect('messages', (states, vEles) => {
            vEles.msgCountEle.textContent = states.messages.length.toString()
        })
        setEffect('focusedNodeIndex', (states, vEles) => {
            const nodes = states.nodes
            const focusedNodeIndex = states.focusedNodeIndex
            const edges = getEdges(nodes, states.maxFindDst)
            const connectionsCount = countConnections(focusedNodeIndex, edges)
            vEles.connectionsCountEle.textContent = connectionsCount.toString()
            vEles.nodeIDEle.textContent = nodes[focusedNodeIndex]?.ID
            vEles.nodeXEle.textContent = nodes[focusedNodeIndex]?.x
            vEles.nodeYEle.textContent = nodes[focusedNodeIndex]?.y
            nodesEdgesRePaint(states, vEles)
        })
        setEffect('messagesCount', (states, vEles) => {
            const { msgCountEle } = vEles
        })
        setEffect('now', (states, vEles) => {
            if (states.messages.length === 0) {
                vEles.messagesCtx.clearRect(0, 0, CANVAS_W, CANVAS_H)
                return
            }
            // 更新画布
            const nodes = states.nodes
            const edges = getEdges(nodes, states.maxFindDst)
            const msgs = states.messages
            const showDist = states.showDist
            const focusedNodeIndex = states.focusedNodeIndex
            vEles.messagesCtx.clearRect(0, 0, CANVAS_W, CANVAS_H)
            paintMessages(vEles, nodes, msgs, performance.now())
        })
        on('init-nodes', states => {
            let nodes = []
            for (let i = 1; i < 12; i++) {
                nodes.push({
                    ID: i + 1,
                    x: Math.round((Math.random() - 0.5) * 600 + CANVAS_W / 2),
                    y: Math.round((Math.random() - 0.5) * 600 + CANVAS_H / 2)
                })
            }
            states.nodes = nodes
        })
        on('send-message', (states, src = 0, dst = 0, sendTime = performance.now(), TTL = 0) => {
            states.messagesCount++
            states.messages = [
                ...states.messages,
                {
                    ID: states.messagesCount,
                    sendTime,
                    TTL,
                    src,
                    dst
                }
            ]
        })
        on('send-message-button-click', (states) => {
            const focusedNodeIndex = states.focusedNodeIndex
            const edges = getEdges(states.nodes, states.maxFindDst)
            for (let i in edges) {
                if (edges[i].node1 === states.focusedNodeIndex) {
                    emit(
                        'send-message',
                        states.focusedNodeIndex,
                        edges[i].node2,
                        states.now,
                        states.maxTTL
                    )
                }
                else if (edges[i].node2 === states.focusedNodeIndex) {
                    emit(
                        'send-message',
                        states.focusedNodeIndex,
                        edges[i].node1,
                        states.now,
                        states.maxTTL
                    )
                }
            }
        })
        on('show-dst', states => {
            states.showDist = !states.showDist
        })
        on('remove-node', states => {
            states.nodes = states.nodes.filter((item, idx) =>
                (idx !== states.focusedNodeIndex)
            )
            if (states.focusedNodeIndex >= states.nodes.length)
                states.focusedNodeIndex = states.nodes.length - 1
        })
        on('canvas-mousedown', (states, e = new MouseEvent) => {
            const x = e.offsetX / C_VIEW_W * CANVAS_W
            const y = e.offsetY / C_VIEW_H * CANVAS_H
            const nodeIndex = mouseOnNode(states.nodes, x, y)
            if (nodeIndex !== -1) {
                states.focusedNodeIndex = nodeIndex
                states.nodeIsPickedUp = nodeIndex
            }
        })
        on('canvas-mousemove', (states, e = new MouseEvent) => {
            const x = e.offsetX / C_VIEW_W * CANVAS_W
            const y = e.offsetY / C_VIEW_H * CANVAS_H
            const i = states.nodeIsPickedUp
            if (i !== -1) {
                let newNodes = [...states.nodes]
                newNodes[i].x = x
                newNodes[i].y = y
                states.nodes = newNodes
            }
        })
        on('canvas-mouseup', (states, e = new MouseEvent) => {
            const x = e.offsetX / C_VIEW_W * CANVAS_W
            const y = e.offsetY / C_VIEW_H * CANVAS_H
            if (states.nodeIsPickedUp !== -1) {
                states.nodeIsPickedUp = -1
            }
        })
        on('add-node', states => {
            states.nodesCount++
            states.nodes = [
                ...states.nodes,
                {
                    ID: states.nodesCount,
                    x: NODE_RADIUS * 4,
                    y: NODE_RADIUS * 4
                }
            ]
            states.focusedNodeIndex = states.nodes.length - 1
        })
        on('ttl-change', (states, e = new Event) => {
            states.maxTTL = e.currentTarget.value
        })
        on('max-find-dst-change', (states, e = new Event) => {
            states.maxFindDst = e.currentTarget.value
        })
        on('tick', (states, now = performance.now()) => {
            states.messages = getNewMessages(states, now)
            states.now = now
        })

        emit('init-nodes')

        mainLoop(performance.now())






        function mainLoop(now = performance.now()) {
            requestAnimationFrame(now => { mainLoop(now) })
            emit('tick', now)
        }
        function getNewMessages(states, now = performance.now()) {
            if (states.messages.length === 0) return states.messages
            let newMessages = [...states.messages]
            const nodes = states.nodes
            const edges = getEdges(nodes)
            // 更新每个消息包
            for (let i = 0; i < newMessages.length; i++) {
                const msg = newMessages[i]
                const srcNode = nodes[msg.src]
                const dstNode = nodes[msg.dst]
                const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                const neededTime = dist / MSG_SPEED
                // 未至终点
                if (now - msg.sendTime < neededTime) {
                    continue
                }
                // 到达终点，包死亡，删除本包
                if (msg.TTL - 1 <= 0) {
                    newMessages = newMessages.filter(item => item.ID !== msg.ID)
                    i--
                    continue
                }
                // 发送新包并删除本包
                for (let i in edges) {
                    const edge = edges[i]
                    let dst = -1

                    if (edge.node1 === msg.dst && edge.node2 !== msg.src) {
                        dst = edge.node2
                    }
                    else if (edge.node2 === msg.dst && edge.node1 !== msg.src) {
                        dst = edge.node1
                    }

                    if (dst === -1) continue

                    states.messagesCount++
                    newMessages.push({
                        ID: states.messagesCount,
                        sendTime: neededTime + msg.sendTime,
                        TTL: msg.TTL - 1,
                        src: msg.dst,
                        dst: dst
                    })
                }
                newMessages = newMessages.filter(item => item.ID !== msg.ID)
                i--
            }
            return newMessages
        }
        function paintEdges(vEles, nodes, edges) {
            vEles.nodesEdgesCtx.strokeStyle = 'rgb(0, 120, 212)'
            vEles.nodesEdgesCtx.lineWidth = 2
            vEles.nodesEdgesCtx.beginPath()
            edges.forEach(edge => {
                const x1 = nodes[edge.node1].x
                const y1 = nodes[edge.node1].y
                const x2 = nodes[edge.node2].x
                const y2 = nodes[edge.node2].y
                vEles.nodesEdgesCtx.moveTo(x1, y1)
                vEles.nodesEdgesCtx.lineTo(x2, y2)
            })
            vEles.nodesEdgesCtx.stroke()
        }
        function nodesEdgesRePaint(states, vEles) {
            const nodes = states.nodes
            const nodeIndex = states.focusedNodeIndex
            const edges = getEdges(nodes, states.maxFindDst)
            const showDist = states.showDist
            const focusedNodeIndex = states.focusedNodeIndex
            vEles.nodesEdgesCtx.clearRect(0, 0, CANVAS_W, CANVAS_H)
            paintEdges(vEles, nodes, edges)
            paintNodes(vEles, nodes, focusedNodeIndex)
            if (showDist) paintEdgeTags(vEles, edges, nodes)
        }
        function paintNodes(vEles, nodes, focusedNodeIndex) {
            const focusedNode = nodes[focusedNodeIndex]
            if (focusedNode === undefined) return
            // 绘制圆点
            nodes.forEach(node => {
                vEles.nodesEdgesCtx.drawImage(
                    ONE_NODE_CIRCLE_CANVAS,
                    node.x - ONE_NODE_CIRCLE_CANVAS.width / 2,
                    node.y - ONE_NODE_CIRCLE_CANVAS.height / 2,
                )
            })
            // 绘制聚焦圆环
            vEles.nodesEdgesCtx.drawImage(
                ONE_NODE_F_CIRCLE_CANVAS,
                focusedNode.x - ONE_NODE_F_CIRCLE_CANVAS.width / 2,
                focusedNode.y - ONE_NODE_F_CIRCLE_CANVAS.height / 2,
            )
            // 绘制标签
            vEles.nodesEdgesCtx.fillStyle = '#0078d4'
            vEles.nodesEdgesCtx.font = '20px consolas'
            vEles.nodesEdgesCtx.textAlign = 'center'
            vEles.nodesEdgesCtx.textBaseline = 'middle'
            nodes.forEach(node => {
                const IDText = node.ID.toString()
                vEles.nodesEdgesCtx.fillText(IDText, node.x, node.y)
            })
        }
        function paintMessages(vEles, nodes, msgs, now) {
            // 绘制圆点
            for (let i = 0; i < msgs.length; i++) {
                const msg = msgs[i]
                const srcNode = nodes[msg.src]
                const dstNode = nodes[msg.dst]
                const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                const neededTime = dist / MSG_SPEED
                const coveredTime = now - msg.sendTime
                const percentage = coveredTime / neededTime
                const coveredX = (dstNode.x - srcNode.x) * percentage
                const coveredY = (dstNode.y - srcNode.y) * percentage
                const x = srcNode.x + coveredX
                const y = srcNode.y + coveredY
                vEles.messagesCtx.drawImage(
                    ONE_MSG_CIRCLE_CANVAS,
                    x - ONE_MSG_CIRCLE_CANVAS.width / 2,
                    y - ONE_MSG_CIRCLE_CANVAS.width / 2
                )
            }
            // 绘制标签
            vEles.messagesCtx.font = '20px consolas'
            vEles.messagesCtx.textAlign = 'center'
            vEles.messagesCtx.textBaseline = 'middle'
            vEles.messagesCtx.fillStyle = '#222222'
            for (let i = 0; i < msgs.length; i++) {
                const msg = msgs[i]
                const srcNode = nodes[msg.src]
                const dstNode = nodes[msg.dst]
                const dist = Math.abs((srcNode.x - dstNode.x) ** 2 + (srcNode.y - dstNode.y) ** 2) ** 0.5
                const neededTime = dist / MSG_SPEED
                const coveredTime = now - msg.sendTime
                const percentage = coveredTime / neededTime
                const coveredX = (dstNode.x - srcNode.x) * percentage
                const coveredY = (dstNode.y - srcNode.y) * percentage
                const x = srcNode.x + coveredX
                const y = srcNode.y + coveredY
                const IDText = msg.ID.toString()
                vEles.messagesCtx.fillText(IDText, x, y + MSG_RADIUS + 10)
            }
        }
        function paintEdgeTags(vEles, edges, nodes) {
            vEles.nodesEdgesCtx.fillStyle = '#222222'
            vEles.nodesEdgesCtx.font = '20px consolas'
            vEles.nodesEdgesCtx.textAlign = 'center'
            vEles.nodesEdgesCtx.textBaseline = 'middle'
            edges.forEach(edge => {
                const dstText = edge.dst.toFixed(2)
                const textWidth = vEles.nodesEdgesCtx.measureText(dstText).width
                const x1 = nodes[edge.node1].x
                const y1 = nodes[edge.node1].y
                const x2 = nodes[edge.node2].x
                const y2 = nodes[edge.node2].y
                const xText = (x1 + x2) / 2
                const yText = (y1 + y2) / 2
                vEles.nodesEdgesCtx.fillText(dstText, xText, yText)
            })
        }
        function getOneMsgCircleCanvas() {
            let canvas = document.createElement('canvas')
            let ctx = canvas.getContext('2d')

            canvas.width = MSG_RADIUS * 2 + 10
            canvas.height = MSG_RADIUS * 2 + 10

            ctx.lineWidth = 2
            ctx.fillStyle = '#dff6dd'
            ctx.strokeStyle = '#107c10'

            ctx.beginPath()
            ctx.arc(canvas.width / 2, canvas.width / 2, MSG_RADIUS, 0, 2 * Math.PI)
            ctx.fill()
            ctx.beginPath()
            ctx.arc(canvas.width / 2, canvas.width / 2, MSG_RADIUS, 0, 2 * Math.PI)
            ctx.stroke()
            return canvas
        }
        function getOneNodeCircleCanvas() {
            let canvas = document.createElement('canvas')
            let ctx = canvas.getContext('2d')

            canvas.width = NODE_RADIUS * 2 + 4
            canvas.height = NODE_RADIUS * 2 + 4

            ctx.lineWidth = 4
            ctx.strokeStyle = '#0078d4'
            ctx.fillStyle = '#c7e0f4'

            ctx.beginPath()
            ctx.arc(canvas.width / 2, canvas.height / 2, NODE_RADIUS, 0, 2 * Math.PI)
            ctx.stroke()
            ctx.fill()

            return canvas
        }
        function getOneNodeFCircleCanvas() {
            let canvas = document.createElement('canvas')
            let ctx = canvas.getContext('2d')

            canvas.width = FOCUS_RADIUS * 2 + 4
            canvas.height = FOCUS_RADIUS * 2 + 4

            ctx.lineWidth = 4
            ctx.strokeStyle = '#0078d4af'

            ctx.beginPath()
            ctx.arc(canvas.width / 2, canvas.height / 2, FOCUS_RADIUS, 0, 2 * Math.PI)
            ctx.stroke()

            return canvas
        }
        function createESV() {
            createESV.defaultState = createESV.defaultState
            // 状态
            let states = { ...createESV.defaultState }
            // 视图元素
            let viewElements = { ...createESV.viewElements }
            // 事件监听器
            let listeners = [{ event: '', listener: () => { } }].slice(1)
            // 状态只读代理
            let statesGetter = { ...createESV.defaultState }
            // 状态读写代理
            let statesProxy = { ...createESV.defaultState }

            // 初始化 statesGetter
            Object.keys(states).forEach(key => {
                Object.defineProperty(statesGetter, key, {
                    get: () => states[key],
                    set: () => { }
                })
            })

            // 初始化 statesProxy
            Object.keys(states).forEach(key => {
                Object.defineProperty(statesProxy, key, {
                    get: () => states[key],
                    set: (val) => { states[key] = val }
                })
            })

            // 默认副作用方法，实现代码智能提示
            const defaultEffectFunc = (states = statesGetter, vEles = viewElements) => { }
            // 设置副作用方法，传入 key 和 func，setter
            const setEffect = (stateKey = '', effectFunc = defaultEffectFunc) => {
                Object.defineProperty(statesProxy, stateKey, {
                    get: () => states[stateKey],
                    set: (val) => {
                        if (val === states[stateKey]) return
                        states[stateKey] = val
                        effectFunc(statesGetter, viewElements)
                    }
                })
                effectFunc(statesGetter, viewElements)
            }

            const defaultListener = (states = statesProxy) => { }
            const on = (event = '', listener = defaultListener) => {
                for (let i in listeners) {
                    if (listeners[i].event === event) {
                        listeners[i].listener = listener
                        return
                    }
                }
                listeners.push({ event, listener })
            }

            // 触发事件的函数
            const emit = (e = '', ...args) => {
                for (let i in listeners) {
                    if (listeners[i].event === e) {
                        listeners[i].listener(statesProxy, ...args)
                        return true
                    }
                }
                console.warn(`[ 未捕获事件 "${e}" ]`)
                return false
            }

            return {
                setEffect,
                emit,
                on
            }
        }
        function countConnections(nodeIndex, edges) {
            return edges.filter(edge => (
                edge.node1 === nodeIndex || edge.node2 === nodeIndex
            )).length
        }
        function mouseOnNode(nodes = [defaultNode].slice(1), x = 0, y = 0) {
            for (let i = nodes.length - 1; i > -1; i--) {
                const xNode = nodes[i].x
                const yNode = nodes[i].y
                const dst = ((xNode - x) ** 2 + (yNode - y) ** 2) ** 0.5
                if (dst <= NODE_RADIUS) return i
            }
            return -1
        }
        function getEdges(nodes = [defaultNode].slice(1), maxFindDst = DEFAULT_MAX_FIND_DST) {
            let edges = []
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const x_1 = nodes[i].x
                    const y_1 = nodes[i].y
                    const x_2 = nodes[j].x
                    const y_2 = nodes[j].y
                    const dst = ((x_1 - x_2) ** 2 + (y_1 - y_2) ** 2) ** 0.5
                    if (dst <= maxFindDst) {
                        edges.push({
                            node1: i,
                            node2: j,
                            dst,
                        })
                    }
                }
            }
            return edges
        }
    </script>
</body>

</html>